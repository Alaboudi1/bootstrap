// ----------------------------------------------------------------------------
//
// Basecode Bootstrap Compiler
// Copyright (C) 2018 Jeff Panici
// All rights reserved.
//
// This software source file is licensed under the terms of MIT license.
// For details, please read the LICENSE file.
//
// ----------------------------------------------------------------------------

support ::= module("support/module.bc");

print("%s\n", "at the very top!");

alpha::compiler::config ::= ns {
    fibonacci := ns {
        length_of_sequence ::= 1000;
    };
};

alpha::compiler::examples ::= ns {
    import alpha::compiler::config::fibonacci;

    count:  u32;
    max:    u16 := 32767;
    name:   string := "fibonacci test program";

    // XXX: initializer/finalizer requirements here
    {
        a: u8;

        a := 2;
        a := a shr 2;
        print("%d\n", a);
    };

//    numbers1: ^[]^u32;
//    numbers2: ^[100]^u32;
//    name_ptr: ^string;

//    (name: string,  len: u32);
//            !=
//    (name: ^string, len: u64);
//
//    (foo:  string,  bar: u32);
//            !=
//    (bing: string,  baz: u32);
//
//    dummy := proc(name: ^string): result: s32, name: string, len: u32 {
//        result := -1;
//        name := "foo";
//        len := 3;
//
//        return -1, "foo", 3;
//    };

//    print(name_ptr^);

    foo: u32 := max * 4;
    boom := length_of_sequence;

    bar_rhs_is_constant: s16 := length_of_sequence * 4;

    count := 1;
    print("what the hell am i doing here?");

    is_this_true := count == (max == 256) && count == (max / 2);

    bar := proc() {
        bing(256);

        bing := proc(z: u64): u64 {
            if z == 0 {
                return 0;
            };
            return z / 2;
        };

        return;
    };

    fib := proc(n: u64 := 10): u64 {
        if n == 0 || n == 1 {
            return n;
        } else {
            value := fib((n - 1) + fib(n - 2));
            print("%s\n", value);
            return value;
        };
    };

    fib_main := proc(): u32 {
        final_fib_value := cast<u32>(fib(length_of_sequence));

    'the_end:
        return final_fib_value;
    };

    fib_main();

};