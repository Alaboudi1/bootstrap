core :: module("../modules/core");

SDL :: ns {
    Keycode :: #type s32;

    Scancode :: enum {
        UNKNOWN := 0;

        /**
         *  \name Usage page $07
         *
         *  These values are from usage page $07 (USB keyboard page).
         */
        /* @{ */

        A := 4;
        B := 5;
        C := 6;
        D := 7;
        E := 8;
        F := 9;
        G := 10;
        H := 11;
        I := 12;
        J := 13;
        K := 14;
        L := 15;
        M := 16;
        N := 17;
        O := 18;
        P := 19;
        Q := 20;
        R := 21;
        S := 22;
        T := 23;
        U := 24;
        V := 25;
        W := 26;
        X := 27;
        Y := 28;
        Z := 29;

        _1 := 30;
        _2 := 31;
        _3 := 32;
        _4 := 33;
        _5 := 34;
        _6 := 35;
        _7 := 36;
        _8 := 37;
        _9 := 38;
        _0 := 39;

        RETURN := 40;
        ESCAPE := 41;
        BACKSPACE := 42;
        TAB := 43;
        SPACE := 44;

        MINUS := 45;
        EQUALS := 46;
        LEFTBRACKET := 47;
        RIGHTBRACKET := 48;
        BACKSLASH := 49; /**< Located at the lower left of the return
                                      *   key on ISO keyboards and at the right end
                                      *   of the QWERTY row on ANSI keyboards.
                                      *   Produces REVERSE SOLIDUS (backslash) and
                                      *   VERTICAL LINE in a US layout; REVERSE
                                      *   SOLIDUS and VERTICAL LINE in a UK Mac
                                      *   layout; NUMBER SIGN and TILDE in a UK
                                      *   Windows layout; DOLLAR SIGN and POUND SIGN
                                      *   in a Swiss German layout; NUMBER SIGN and
                                      *   APOSTROPHE in a German layout; GRAVE
                                      *   ACCENT and POUND SIGN in a French Mac
                                      *   layout; and ASTERISK and MICRO SIGN in a
                                      *   French Windows layout.
                                      */
        NONUSHASH := 50; /**< ISO USB keyboards actually use this code
                                      *   instead of 49 for the same key; but all
                                      *   OSes I've seen treat the two codes
                                      *   identically. So; as an implementor; unless
                                      *   your keyboard generates both of those
                                      *   codes and your OS treats them differently;
                                      *   you should generate BACKSLASH
                                      *   instead of this code. As a user; you
                                      *   should not rely on this code because SDL
                                      *   will never generate it with most (all?)
                                      *   keyboards.
                                      */
        SEMICOLON := 51;
        APOSTROPHE := 52;
        GRAVE := 53; /**< Located in the top left corner (on both ANSI
                                  *   and ISO keyboards). Produces GRAVE ACCENT and
                                  *   TILDE in a US Windows layout and in US and UK
                                  *   Mac layouts on ANSI keyboards; GRAVE ACCENT
                                  *   and NOT SIGN in a UK Windows layout; SECTION
                                  *   SIGN and PLUS-MINUS SIGN in US and UK Mac
                                  *   layouts on ISO keyboards; SECTION SIGN and
                                  *   DEGREE SIGN in a Swiss German layout (Mac:
                                  *   only on ISO keyboards); CIRCUMFLEX ACCENT and
                                  *   DEGREE SIGN in a German layout (Mac: only on
                                  *   ISO keyboards); SUPERSCRIPT TWO and TILDE in a
                                  *   French Windows layout; COMMERCIAL AT and
                                  *   NUMBER SIGN in a French Mac layout on ISO
                                  *   keyboards; and LESS-THAN SIGN and GREATER-THAN
                                  *   SIGN in a Swiss German; German; or French Mac
                                  *   layout on ANSI keyboards.
                                  */
        COMMA := 54;
        PERIOD := 55;
        SLASH := 56;

        CAPSLOCK := 57;

        F1 := 58;
        F2 := 59;
        F3 := 60;
        F4 := 61;
        F5 := 62;
        F6 := 63;
        F7 := 64;
        F8 := 65;
        F9 := 66;
        F10 := 67;
        F11 := 68;
        F12 := 69;

        PRINTSCREEN := 70;
        SCROLLLOCK := 71;
        PAUSE := 72;
        INSERT := 73; /**< insert on PC; help on some Mac keyboards (but
                                       does send code 73; not 117) */
        HOME := 74;
        PAGEUP := 75;
        DELETE := 76;
        END := 77;
        PAGEDOWN := 78;
        RIGHT := 79;
        LEFT := 80;
        DOWN := 81;
        UP := 82;

        NUMLOCKCLEAR := 83; /**< num lock on PC; clear on Mac keyboards
                                         */
        KP_DIVIDE := 84;
        KP_MULTIPLY := 85;
        KP_MINUS := 86;
        KP_PLUS := 87;
        KP_ENTER := 88;
        KP_1 := 89;
        KP_2 := 90;
        KP_3 := 91;
        KP_4 := 92;
        KP_5 := 93;
        KP_6 := 94;
        KP_7 := 95;
        KP_8 := 96;
        KP_9 := 97;
        KP_0 := 98;
        KP_PERIOD := 99;

        NONUSBACKSLASH := 100; /**< This is the additional key that ISO
                                            *   keyboards have over ANSI ones;
                                            *   located between left shift and Y.
                                            *   Produces GRAVE ACCENT and TILDE in a
                                            *   US or UK Mac layout; REVERSE SOLIDUS
                                            *   (backslash) and VERTICAL LINE in a
                                            *   US or UK Windows layout; and
                                            *   LESS-THAN SIGN and GREATER-THAN SIGN
                                            *   in a Swiss German; German; or French
                                            *   layout. */
        APPLICATION := 101; /**< windows contextual menu; compose */
        POWER := 102; /**< The USB document says this is a status flag;
                                   *   not a physical key - but some Mac keyboards
                                   *   do have a power key. */
        KP_EQUALS := 103;
        F13 := 104;
        F14 := 105;
        F15 := 106;
        F16 := 107;
        F17 := 108;
        F18 := 109;
        F19 := 110;
        F20 := 111;
        F21 := 112;
        F22 := 113;
        F23 := 114;
        F24 := 115;
        EXECUTE := 116;
        HELP := 117;
        MENU := 118;
        SELECT := 119;
        STOP := 120;
        AGAIN := 121;   /**< redo */
        UNDO := 122;
        CUT := 123;
        COPY := 124;
        PASTE := 125;
        FIND := 126;
        MUTE := 127;
        VOLUMEUP := 128;
        VOLUMEDOWN := 129;
    /* not sure whether there's a reason to enable these */
    /*     LOCKINGCAPSLOCK := 130;  */
    /*     LOCKINGNUMLOCK := 131; */
    /*     LOCKINGSCROLLLOCK := 132; */
        KP_COMMA := 133;
        KP_EQUALSAS400 := 134;

        INTERNATIONAL1 := 135; /**< used on Asian keyboards; see
                                                footnotes in USB doc */
        INTERNATIONAL2 := 136;
        INTERNATIONAL3 := 137; /**< Yen */
        INTERNATIONAL4 := 138;
        INTERNATIONAL5 := 139;
        INTERNATIONAL6 := 140;
        INTERNATIONAL7 := 141;
        INTERNATIONAL8 := 142;
        INTERNATIONAL9 := 143;
        LANG1 := 144; /**< Hangul/English toggle */
        LANG2 := 145; /**< Hanja conversion */
        LANG3 := 146; /**< Katakana */
        LANG4 := 147; /**< Hiragana */
        LANG5 := 148; /**< Zenkaku/Hankaku */
        LANG6 := 149; /**< reserved */
        LANG7 := 150; /**< reserved */
        LANG8 := 151; /**< reserved */
        LANG9 := 152; /**< reserved */

        ALTERASE := 153; /**< Erase-Eaze */
        SYSREQ := 154;
        CANCEL := 155;
        CLEAR := 156;
        PRIOR := 157;
        RETURN2 := 158;
        SEPARATOR := 159;
        OUT := 160;
        OPER := 161;
        CLEARAGAIN := 162;
        CRSEL := 163;
        EXSEL := 164;

        KP_00 := 176;
        KP_000 := 177;
        THOUSANDSSEPARATOR := 178;
        DECIMALSEPARATOR := 179;
        CURRENCYUNIT := 180;
        CURRENCYSUBUNIT := 181;
        KP_LEFTPAREN := 182;
        KP_RIGHTPAREN := 183;
        KP_LEFTBRACE := 184;
        KP_RIGHTBRACE := 185;
        KP_TAB := 186;
        KP_BACKSPACE := 187;
        KP_A := 188;
        KP_B := 189;
        KP_C := 190;
        KP_D := 191;
        KP_E := 192;
        KP_F := 193;
        KP_XOR := 194;
        KP_POWER := 195;
        KP_PERCENT := 196;
        KP_LESS := 197;
        KP_GREATER := 198;
        KP_AMPERSAND := 199;
        KP_DBLAMPERSAND := 200;
        KP_VERTICALBAR := 201;
        KP_DBLVERTICALBAR := 202;
        KP_COLON := 203;
        KP_HASH := 204;
        KP_SPACE := 205;
        KP_AT := 206;
        KP_EXCLAM := 207;
        KP_MEMSTORE := 208;
        KP_MEMRECALL := 209;
        KP_MEMCLEAR := 210;
        KP_MEMADD := 211;
        KP_MEMSUBTRACT := 212;
        KP_MEMMULTIPLY := 213;
        KP_MEMDIVIDE := 214;
        KP_PLUSMINUS := 215;
        KP_CLEAR := 216;
        KP_CLEARENTRY := 217;
        KP_BINARY := 218;
        KP_OCTAL := 219;
        KP_DECIMAL := 220;
        KP_HEXADECIMAL := 221;

        LCTRL := 224;
        LSHIFT := 225;
        LALT := 226; /**< alt; option */
        LGUI := 227; /**< windows; command (apple); meta */
        RCTRL := 228;
        RSHIFT := 229;
        RALT := 230; /**< alt gr; option */
        RGUI := 231; /**< windows; command (apple); meta */

        MODE := 257;    /**< I'm not sure if this is really not covered
                                     *   by any of the above; but since there's a
                                     *   special KMOD_MODE for it I'm adding it here
                                     */

        /* @} *//* Usage page $07 */

        /**
         *  \name Usage page $0C
         *
         *  These values are mapped from usage page $0C (USB consumer page).
         */
        /* @{ */

        AUDIONEXT := 258;
        AUDIOPREV := 259;
        AUDIOSTOP := 260;
        AUDIOPLAY := 261;
        AUDIOMUTE := 262;
        MEDIASELECT := 263;
        WWW := 264;
        MAIL := 265;
        CALCULATOR := 266;
        COMPUTER := 267;
        AC_SEARCH := 268;
        AC_HOME := 269;
        AC_BACK := 270;
        AC_FORWARD := 271;
        AC_STOP := 272;
        AC_REFRESH := 273;
        AC_BOOKMARKS := 274;

        /* @} *//* Usage page $0C */

        /**
         *  \name Walther keys
         *
         *  These are values that Christian Walther added (for mac keyboard?).
         */
        /* @{ */

        BRIGHTNESSDOWN := 275;
        BRIGHTNESSUP := 276;
        DISPLAYSWITCH := 277; /**< display mirroring/dual display
                                               switch; video mode switch */
        KBDILLUMTOGGLE := 278;
        KBDILLUMDOWN := 279;
        KBDILLUMUP := 280;
        EJECT := 281;
        SLEEP := 282;

        APP1 := 283;
        APP2 := 284;

        /* @} *//* Walther keys */

        /**
         *  \name Usage page $0C (additional media keys)
         *
         *  These values are mapped from usage page $0C (USB consumer page).
         */
        /* @{ */

        AUDIOREWIND := 285;
        AUDIOFASTFORWARD := 286;

        /* @} *//* Usage page $0C (additional media keys) */

        /* Add any other keys here. */

        NUM_SCANCODES := 512; /**< not a key; just marks the number of scancodes
                                     for array bounds */
    };

    Keysym :: struct {
        scancode: Scancode;
        sym: Keycode;
        mod: u16;
        unused: u32;
    };

    /**
     *  \brief Fields shared by every event
     */
    Common_Event :: struct {
        type: u32;
        timestamp: u32;   /**< In milliseconds, populated using SDL_GetTicks() */
    };

    /**
     *  \brief Window state change event data (event.window.*)
     */
    Window_Event :: struct {
        type: u32;        /**< ::SDL_WINDOWEVENT */
        timestamp: u32;   /**< In milliseconds, populated using SDL_GetTicks() */
        window_id: u32;   /**< The associated window */
        event: u8;        /**< ::SDL_WindowEventID */
        padding1: u8;
        padding2: u8;
        padding3: u8;
        data1: s32;       /**< event dependent data */
        data2: s32;       /**< event dependent data */
    };

    /**
     *  \brief Keyboard button event structure (event.key.*)
     */
    Keyboard_Event :: struct {
        type: u32;        /**< ::SDL_KEYDOWN or ::SDL_KEYUP */
        timestamp: u32;   /**< In milliseconds, populated using SDL_GetTicks() */
        window_id: u32;   /**< The window with keyboard focus, if any */
        state: u8;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
        repeat: u8;       /**< Non-zero if this is a key repeat */
        padding2: u8;
        padding3: u8;
        keysym: Keysym;   /**< The key that was pressed or released */
    };

    ///////////////////////////////////////////////////////////////////////////

    Color :: struct {
        r: u8;
        g: u8;
        b: u8;
        a: u8;
    };

    Palette :: struct {
        ncolors: s32;
        colors: ^Color;
        version: u32;
        refcount: s32;
    };

    Pixel_Format :: struct {
        format: u32;
        palette: ^Palette;
        bits_per_pixel: u8;
        bytes_per_pixel: u8;
        padding: u16;
        rmask: u32;
        gmask: u32;
        bmask: u32;
        amask: u32;
        rloss: u8;
        gloss: u8;
        bloss: u8;
        aloss: u8;
        rshift: u8;
        gshift: u8;
        bshift: u8;
        ashift: u8;
        refcount : s32;
        next: ^Pixel_Format;
    };

    Blit_Map :: struct {};

    Point   :: struct {
        x: s32;
        y: s32;
    };

    Rect    :: struct {
        x: s32;
        y: s32;
        w: s32;
        h: s32;
    };

    Window  :: struct {};

    Surface :: struct {
        flags: u32;
        format: ^Pixel_Format;
        w: s32;
        h: s32;
        pitch: s32;
        pixels: ^u8;
        userdata: ^u8;
        locked: s32;
        lock_data: ^u8;
        clip_rect: Rect;
        map: ^Blit_Map;
        refcount: s32;
    };

    INIT_TIMER          :: $00000001;
    INIT_AUDIO          :: $00000010;
    INIT_VIDEO          :: $00000020;
    INIT_JOYSTICK       :: $00000200;
    INIT_HAPTIC         :: $00001000;
    INIT_GAMECONTROLLER :: $00002000;
    INIT_EVENTS         :: $00004000;
    INIT_NOPARACHUTE    :: $00100000;
    INIT_EVERYTHING     :: INIT_TIMER
                           | INIT_AUDIO
                           | INIT_VIDEO
                           | INIT_EVENTS
                           | INIT_JOYSTICK
                           | INIT_HAPTIC
                           | INIT_GAMECONTROLLER;

    WINDOWPOS_UNDEFINED_MASK :: $1FFF0000;
    WINDOWPOS_UNDEFINED      :: WINDOWPOS_UNDEFINED_MASK;

    WINDOWPOS_CENTERED_MASK  :: $2FFF0000;
    WINDOWPOS_CENTERED       :: WINDOWPOS_CENTERED_MASK;

    FULLSCREEN         :: $00000001;
    OPENGL             :: $00000002;
    SHOWN              :: $00000004;
    HIDDEN             :: $00000008;
    BORDERLESS         :: $00000010;
    RESIZABLE          :: $00000020;
    MINIMIZED          :: $00000040;
    MAXIMIZED          :: $00000080;
    INPUT_GRABBED      :: $00000100;
    INPUT_FOCUS        :: $00000200;
    MOUSE_FOCUS        :: $00000400;
    FULLSCREEN_DESKTOP :: FULLSCREEN | $00001000;
    FOREIGN            :: $00000800;
    ALLOW_HIGHDPI      :: $00002000;
    MOUSE_CAPTURE      :: $00004000;
    ALWAYS_ON_TOP      :: $00008000;
    SKIP_TASKBAR       :: $00010000;
    UTILITY            :: $00020000;
    TOOLTIP            :: $00040000;
    POPUP_MENU         :: $00080000;
    VULKAN             :: $10000000;

    Event_Type :: enum {
        FIRSTEVENT     := 0;     /**< Unused (do not remove) */

        /* Application events */
        QUIT           := $100; /**< User-requested quit */

        /* These application events have special meaning on iOS; see README-ios.md for details */
        APP_TERMINATING;        /**< The application is being terminated by the OS
                                         Called on iOS in applicationWillTerminate()
                                         Called on Android in onDestroy()
                                    */
        APP_LOWMEMORY;          /**< The application is low on memory; free memory if possible.
                                         Called on iOS in applicationDidReceiveMemoryWarning()
                                         Called on Android in onLowMemory()
                                    */
        APP_WILLENTERBACKGROUND; /**< The application is about to enter the background
                                         Called on iOS in applicationWillResignActive()
                                         Called on Android in onPause()
                                    */
        APP_DIDENTERBACKGROUND; /**< The application did enter the background and may not get CPU for some time
                                         Called on iOS in applicationDidEnterBackground()
                                         Called on Android in onPause()
                                    */
        APP_WILLENTERFOREGROUND; /**< The application is about to enter the foreground
                                         Called on iOS in applicationWillEnterForeground()
                                         Called on Android in onResume()
                                    */
        APP_DIDENTERFOREGROUND; /**< The application is now interactive
                                         Called on iOS in applicationDidBecomeActive()
                                         Called on Android in onResume()
                                    */

        /* Window events */
        WINDOWEVENT    := $200; /**< Window state change */
        SYSWMEVENT;             /**< System specific event */

        /* Keyboard events */
        KEYDOWN        := $300; /**< Key pressed */
        KEYUP;                  /**< Key released */
        TEXTEDITING;            /**< Keyboard text editing (composition) */
        TEXTINPUT;              /**< Keyboard text input */
        KEYMAPCHANGED;          /**< Keymap changed due to a system event such as an
                                         input language or keyboard layout change.
                                    */

        /* Mouse events */
        MOUSEMOTION    := $400; /**< Mouse moved */
        MOUSEBUTTONDOWN;        /**< Mouse button pressed */
        MOUSEBUTTONUP;          /**< Mouse button released */
        MOUSEWHEEL;             /**< Mouse wheel motion */

        /* Joystick events */
        JOYAXISMOTION  := $600; /**< Joystick axis motion */
        JOYBALLMOTION;          /**< Joystick trackball motion */
        JOYHATMOTION;           /**< Joystick hat position change */
        JOYBUTTONDOWN;          /**< Joystick button pressed */
        JOYBUTTONUP;            /**< Joystick button released */
        JOYDEVICEADDED;         /**< A new joystick has been inserted into the system */
        JOYDEVICEREMOVED;       /**< An opened joystick has been removed */

        /* Game controller events */
        CONTROLLERAXISMOTION  := $650; /**< Game controller axis motion */
        CONTROLLERBUTTONDOWN;          /**< Game controller button pressed */
        CONTROLLERBUTTONUP;            /**< Game controller button released */
        CONTROLLERDEVICEADDED;         /**< A new Game controller has been inserted into the system */
        CONTROLLERDEVICEREMOVED;       /**< An opened Game controller has been removed */
        CONTROLLERDEVICEREMAPPED;      /**< The controller mapping was updated */

        /* Touch events */
        FINGERDOWN      := $700;
        FINGERUP;
        FINGERMOTION;

        /* Gesture events */
        DOLLARGESTURE   := $800;
        DOLLARRECORD;
        MULTIGESTURE;

        /* Clipboard events */
        CLIPBOARDUPDATE := $900; /**< The clipboard changed */

        /* Drag and drop events */
        DROPFILE        := $1000; /**< The system requests a file open */
        DROPTEXT;                 /**< text/plain drag-and-drop event */
        DROPBEGIN;                /**< A new set of drops is beginning (NULL filename) */
        DROPCOMPLETE;             /**< Current set of drops is now complete (NULL filename) */

        /* Audio hotplug events */
        AUDIODEVICEADDED := $1100; /**< A new audio device is available */
        AUDIODEVICEREMOVED;        /**< An audio device has been removed. */

        /* Render events */
        RENDER_TARGETS_RESET := $2000; /**< The render targets have been reset and their contents need to be updated */
        RENDER_DEVICE_RESET; /**< The device has been reset and all textures need to be recreated */

        /** Events ::USEREVENT through ::LASTEVENT are for your use;
         *  and should be allocated with RegisterEvents()
         */
        USEREVENT    := $8000;

        /**
         *  This last event is only for bounding internal arrays
         */
        LASTEVENT    := $FFFF;
    };

    Event :: union {
        type: u32;                  /**< Event type, shared with all events */
        common: Common_Event;       /**< Common event data */
        window: Window_Event;       /**< Window event data */
        key: Keyboard_Event;        /**< Keyboard event data */
        /* This is necessary for ABI compatibility between Visual C++ and GCC
           Visual C++ will respect the push pack pragma and use 52 bytes for
           this structure, and GCC will use the alignment of the largest datatype
           within the union, which is 8 bytes.

           So... we'll add padding to force the size to be 56 bytes for both.
        */
        padding: [56]u8;
    };

    @library "SDL2";
    #foreign {
        Quit                :: proc() @alias "SDL_Quit";
        Delay               :: proc(ms: u32) @alias "SDL_Delay";
        Init                :: proc(flags: u32): s32 @alias "SDL_Init";
        PollEvent           :: proc(event: ^Event): s32 @alias "SDL_PollEvent";
        DestroyWindow       :: proc(window: ^Window) @alias "SDL_DestroyWindow";
        UpdateWindowSurface :: proc(window: ^Window): s32 @alias "SDL_UpdateWindowSurface";
        GetWindowSurface    :: proc(window: ^Window): ^Surface @alias "SDL_GetWindowSurface";
        FillRect            :: proc(surface: ^Surface, rect: ^Rect, color: u32): s32 @alias "SDL_FillRect";
        CreateWindow        :: proc(title: ^u8, x: s32, y: s32, w: s32, h: s32, flags: u32): ^Window @alias "SDL_CreateWindow";
    } @parent_scope;
};

#run {
    assert(SDL::Init(SDL::INIT_VIDEO) >= 0, "SDL could not be initialized!");
    
    window := SDL::CreateWindow(
        "Test Window", 
        SDL::WINDOWPOS_CENTERED,
        SDL::WINDOWPOS_CENTERED,
        1280, 
        1024, 
        SDL::OPENGL | SDL::SHOWN);
    assert(window != nil, "window not initialized!");
    rect: SDL::Rect;
    with rect {
        .x := 0;
        .y := 0;
        .w := 1280;
        .h := 1024;
    };

    surface := SDL::GetWindowSurface(window);
    // XXX: struct padding issues
    print("surface.flags := %d\n", surface.flags);
    print("surface.format:= $%016X\n", surface.format);
    print("surface.w     := %d\n", surface.w);
    print("surface.h     := %d\n", surface.h);
    print("surface.pitch := %d\n", surface.pitch);

    running := true;
    delta: s32 := -16;
    color: u32 := $FFFFFFFF;
    e: SDL::Event;
    while running {
        SDL::PollEvent(address_of(e));
        switch e.type {
            case SDL::Event_Type.QUIT => {
                running := false;
            };
            case SDL::Event_Type.KEYDOWN => {
                print("key pressed: %d\n", e.key.keysym.sym);
            };
        };

        SDL::FillRect(surface, nil, color);
        SDL::UpdateWindowSurface(window);

        color +:= delta;
        if color == $00000010 {
            delta := -delta;
        };

        SDL::Delay(60);
    };

    SDL::DestroyWindow(window);

    SDL::Quit();
};
