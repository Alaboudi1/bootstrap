// ----------------------------------------------------------------------------
//
// Basecode Bootstrap Compiler
// Copyright (C) 2018 Jeff Panici
// All rights reserved.
//
// This software source file is licensed under the terms of MIT license.
// For details, please read the LICENSE file.
//
// ----------------------------------------------------------------------------

core :: module("../modules/core");

@library "basecode";
#foreign str_test_ptr :: proc(str: ^string);

@library "basecode";
#foreign str_test_cpy :: proc(str: string);

pass_by_value :: proc(msg: string) {
    print("msg.length := %d\n", msg.length);
    print("msg.capacity := %d\n", msg.capacity);
    print("msg.data := %s\n", msg.data);
};

flags_t :: tuple(foo := false, bar := false, bing := true, bong := true);

tuple_by_value :: proc(flags: flags_t) {
    print("flags.foo  := %hhu\n", flags.foo);
    print("flags.bar  := %hhu\n", flags.bar);
    print("flags.bing := %hhu\n", flags.bing);
    print("flags.bong := %hhu\n", flags.bong);
};

print("%s: %d, %f\n", "integer and float", 22, 3.5);

temp: string := "hello world!";

// ffi
str_test_ptr(address_of(temp));
str_test_cpy(temp);

// native
pass_by_value(temp);

my_flags: flags_t;
my_flags.foo := true;
my_flags.bing := false;
tuple_by_value(my_flags);

min :: proc(a: u32, b: u32): u32 {
    if a < b {
        return a;
    } else {
        return b;
    };
};

max :: proc(a: u32, b: u32): u32 {
    if a > b {
        return a;
    } else {
        return b;
    };
};

next_power_of_two :: proc(n: u32): u32 {
    n -:= 1;
    n |:= n shr 1;
    n |:= n shr 2;
    n |:= n shr 4;
    n |:= n shr 8;
    n |:= n shr 16;
    n +:= 1;
    return n;
};

// XXX: the interpreter isn't handling zoned values very well
//      on the stack, there typically noise in the upper 32-bits which
//      causes issues for smaller sizes
assign_string :: proc(str: ^string, lit: ^u8, len: u32) {
    str.length := len;
    str.capacity := next_power_of_two(len + 1);
    str.data := alloc(cast<u64>(str.capacity));
    fill(str.data, 0, cast<u64>(str.capacity));
    copy(str.data, lit, cast<u64>(len));
};

vector3 :: struct {
    x: f32;
    y: f32;
    z: f32;
};

player :: struct {
    name:  string;
    lives: u8  := 3;
    hp:    u16 := 15000;
};

entity :: struct {
    name: string;
    pos:  vector3;
    data: ^player;
};

print("next_power_of_two          := %d\n", next_power_of_two(33));
print("max(32, next_power_of_two) := %d\n", max(32, next_power_of_two(33)));

jeff: player;
with jeff {
    assign_string(address_of(.name), "jeff", 4);

    print(".name.length   := %d\n", .name.length);
    print(".name.capacity := %d\n", .name.capacity);
    print(".name.data     := %s\n", .name.data);
};

//jeff_entity: entity;
//assign_string(address_of(jeff_entity.name), "entity: jeff", 12);
//jeff_entity.pos.x := 1.0;
//jeff_entity.pos.y := 1.0;
//jeff_entity.pos.z := 1.0;
//jeff_entity.data := address_of(jeff);
