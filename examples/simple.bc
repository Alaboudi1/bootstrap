// Issues
//

// 0. how to encode the spread operator?
//

// 1. block filtering in program::on_emit isn't strong enough.
//    a. blocks that belong to procedures should be flagged as such

// 2. types
//    a. type metadata needs to be emitted by the compiler
//    b. type initializers & finalizers
//    c. type_of(x)
//    d. align_of(x)
//    e. size_of(x)

// 3. finish constant expression folding

// 4. rework constant assignment syntax
//      x :: "foo";

// 5. array initializer lists
// 6. dictionary initializer lists
// 7. tuples
// 8. structs/unions/enums
//    a. dot defer syntax
// 9. with syntax for composite types
// 10. context implicit

// 11. procedure call verification against type
//     a. named, unordered arguments, e.g. print(a, 2, 10, 3, format := "a = %hhu\n");
//     b. procedure stack frame
//     c. return fixes

// 12. #if/#elseif/#else
// 13. assert

// 14. fix multiple assignment/destructuring

// 15. assembler label names need to be fully qualified
// 16. disassemble strings as comma-separated list of .db instead of lines

// 17. cast operator & rules
//     a. transmute<type>()

@library "libalpha-core.dylib";
#foreign print := proc(format: string, values: ...any) @alias "fmt_print";

print("\n------ this code is running in the compiler!\n");
print("hello world\n");

// XXX: there's a memory alignment issue with the signed integer
s := -32768;
b := 6;
c := 7;

d: u32;
d := ((b * c) / 2) % 2;
//b, c := c, b;

a := 2;
a := a shl 4;

print("a := %hhu\n", a);
print("s := %d\n", s);
print("d := %d\n", d);

//if a == 32 {
//    print("we have a match!\n");
//} else {
//    print("no match\n");
//};

print("----------------------------------------------\n\n");