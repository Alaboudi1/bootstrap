NOTES
------------------------
Steps to reach feature complete for the bootstrap compiler:

- type-baking for generics
- type-promotion errors for procedure_call
- lambdas
- consolidate errors/return errors from all appropriate locations

After these tasks are complete (most are covered below) then the assembler should be enhanced to
support variable directives and label operators.

Refactor session:
    - need to introduce a general job system (not necessarily multi-threaded)
    - the work that session does should be broken into jobs
    - jobs can depend on other jobs
    - session should track "versions" of the code DOM:
        - associated assembler constructs ("units"/"sections" and their instruction_blocks)
        - source representation
        - changes to debugger to support "compile type" debugging so we can see the
            different versions as the meta-program makes changes and "runtime" where
            things are now fixed and we're doing classical debugging.

Compiler:
    - Expose structures and API for meta-programming
    - Add an event callback system where the Basecode meta-program can pass a pointer to a procedure
      and receive callbacks when the compiler does something, e.g. parse a statement, translate a statement
      to the compiler DOM, etc.
    - Need to track changes to the DOM (set of pointers to element) and when a meta-program phase finishes
      the compiler needs to version the DOM by regenerating new code.  This cycle repeats until
      no more meta-programs need to run.

IDEAS
---------

QUESTIONS
---------

TASKS
-----
LEXER:
- PERF: refactor the lexer thusly:
    1. add a bool tokenize(common::result& r) method that tokenizes the entire source_file
       all in one go.  store the tokens in an internal vector.
    2. the new tokenize method should use a direct-threaded-type model to process the file.
    3. next and has_next both change to be based on the internal vector.

=======

PARSER:
- BUG: fix assignment so that groups of lhs/rhs are together.
- FIX: composite binary op + assign has parser precedence issues. may need to
       programmatically wrap the rhs in an expression_group.

=======

COMPILER:
- ADD: type_name_formatter that eases construction of unique type names.

- BUG: redefining an identifier with another type doesn't give nice errors.

- BUG: fix assignment in ast_evaluator so it properly handles sets of multiple assignment/multiple return.
- BUG: fix binary_operator type checking in session so it properly supports multiple assignment/multiple return

- BUG: don't emit the template procedure_instance
- NEW: @initializer/@finalizer linkages
- NEW: operator overloading procedure linkages, e.g.
        @binary_operator "+";
        add_foos :: proc(lhs, rhs: foo): foo {
            // XXX: do the add for "foo" type
        };

        @unary_operator "-";
        negate_a_foo :: proc(lhs: foo): foo {
            // XXX: do the negation for "foo" type
        };

        should these use pointers?
- NEW: variables that are a family_type need to record two things:
        - which type within the family tree is "selected" based on it's value;
        - the value itself
- NEW: UFCS against a pointer-to-family-type does one of the following:
        a) if, at compile time, we know the type of the variant, we use that type
            to find the procedure match;
        b) otherwise, we generate a dispatch stub for the family-type of the LHS
            variable that implements a type-switch where the correct procedure
            is invoked.

        NOTES: there's no inheritance here.  the family-type unifies unrelated types
                together based on programmer intention.  this proposal extends
                UFCS to dynamically generate dispatch proxy procedures to emulate
                dynamic dispatch commonly seen in object-oriented languages.
        Example:

        // create some data types
        point :: struct {
            x, y: f32 := 0;
        };

        circle :: struct {
            name: string;
            pos: point;
            radius: f32 := 1.0;
        };

        rect :: struct {
            name: string;
            pos: point;
            width, height: u32;
        };

        shape :: family(circle, rect);

        // create overloaded procedures that "draw" each shape
        draw :: proc(self: ^circle) {
        };

        draw :: proc(self: ^rect) {
        };

        // now, let's create some shapes

        // a family type variable is a variant, holding the type and value
        // of anything assigned to it.
        a: shape := new<circle>(
            name := "circle 1",     // NOTE: this assumes an assignment operator overload
            pos := new<point>(x := 10.0, y:= 10.0),
            radius := 13.0);
        b: shape := new<rect>(
            name := "rect 1",       // NOTE: this assumes an assignment operator overload
            pos := new<point>(x := 20.0, y:= 20.0),
            width := 10,
            height := 10);

        // UFCS follows rules to find the correct procedure.
        a.draw(); // => __dispatch_draw_on_shapes__(address_of(a));
                  // dispatch calls draw for circle

        b.draw(); // => __dispatch_draw_on_shapes__(address_of(b));
                  // dispatch calls draw for rect

        // NOTE: most of the time, we won't know what the value of the variant is
        //      at compile time.  in these cases, we need to generate a dispatch proxy.
        //
        // note, the return type would match the procedure we're dispatching for.
        // draw has no return type, so the proxy matches.
        //
        __dispatch_draw_on_shapes__ :: proc(self: ^shape /* draw's parameters would be mirrored */) {
            switch v {
                case #type circle => {
                    draw(address_of(self.circle));
                };

                case #type rect => {
                    draw(address_of(self.rect));
                };
            }
        };

- NEW: implement procedure instance baking
- NEW: struct/union instance baking
- REFACTOR: ast_evaluator::add_identifier_to_scope

=======

VM:
- NEW: enhance the built-in debugger to support
        source-level debugging in addition to byte-code.

=======

EMITTER:
- BUG: multiple assignment code generation doesn't allow for value swaps.

- FIX: copy semantics:
    1. DONE: module-var to module-var
    2. module-var to stack-var
    3. stack-var to module-var
    4. any var to parameter
    5. return parameter to any var

- BUG: the new fixed-length array implementation that uses a structure, e.g.
        sample_array :: struct<T> {
            length: u32;
            data: ^T;
        };

        isn't immediately compatible with the outside world.  the best fix (maybe) is
        to place the buffer ahead of the struct itself and keep track of the
        raw buffer address.
- NEW: use/def in compiler::block for variables
        should supplant byte_code_emitter::referenced_module_variables
- NEW: k-coloring for register allocation

- NEW: variables that are a family_type need to record two things:
        - which type within the family tree is "selected" based on it's value;
        - the value itself

=======

OTHER:
- NEW: consolidate all errors into one class along with constants for quick lookup.
- BUG: fix utf8 streaming issues in lexer/source_file
- BUG: add missing errors
- BUG: fix location for elements
- BUG: lambda procedure type checking
- BUG: type parameter propagation

DONE
----
- implement namespaces in the parser
- implement enumerations in lexer/parser
- implement object/pointer dereference with . operator
- fix precedence of @attribute in parser
- implement defer in parser (executed in reverse order)``
- implement with in parser
- ast to internal model
- what is the type of a function?
- remove scope, symbol_table, constant_expression_evaluator, type_inference_engine
- boolean_literal
- procedure subclass for type
- type needs to include type parameters
- require return statement
    * multiple return values
- does binary_operator/unary_operator need element* or just expression*
- base types should be statically defined in program
- comment
- implement block comments /* */ in the lexer/parser
- determine the best way to create new elements
    * maybe follow a similar pattern to ast_builder
- string_literal
- labels
- alias
- cast
- return
- if/else if/else
- FIX: comma token is being gobbled up during infix parsing
- identifier/namespace handling
- create parameter identifiers in block
- review: procedure calls
- type inference
- need to work out how proc types should work
- are the compiler directives bootstrapped using the @directive attribute so
  therefore all implemented in Basecode?
- type inference:
    * add function on program that recursively attempts to finalize
        type inference for identifiers after compile finishes.
- ffi:
    * directive (#foreign) should register procedure_type with vm::terp
    * attribute for library module specific, e.g. @library "libfoo.so", etc.
    * refactor project structure:
        1. core compiler should be shared library
        2. bac command-line tool should be executable target
- data definitions
    * compiler::type needs a size and composite_type needs to compute size based on fields
    * MOVE: as_string() to element and add as_integer(), as_float(), as_bool()
    * compiler::string_type, compiler::array_type, compiler::any_type should
      inherit from compiler::composite_type and initialize should
      set up their fields.
    * string interning
    * encode constant parameters
- FIX: graph generator is not escaping quotes
- use initializer to handle custom construction of values?
- basic block:
    * emit actual instructions for block behavior
    * local variables/parameters on stack
        * how do blocks link to one another in sequence?
- assignment needs to check is_constant on the rhs to determine if
  a bin_op assignment is needed or if the value can be expressed directly
- assembler:
    * need to build out the api here
- add support to compiler:
    * module(expr) instead of #load
    * namespace importing
        - import <expr> [from <identifier>]
- FIX: now that boost is available, get the executable full path
- FIX: pass executable path into session so paths for module files can be full paths
- FIX: the AST node graph output option shouldn't take a filename now.  the filename should
        be based on the module compiled.  the option should just be a flag.
- NEW: add command line flags that are passed into the compiler as definitions
- consolidate array_constructor and tuple, map, and struct/union/enum into type_literal
- create_type_identifier needs an overhaul:
    * parsing of pointer types and spreads needs to utilize the prefix parsing
    * parsing of array subscripts needs to be folded into the existing subscript parser
    * specification of a dynamic array [] needs to do something other an generate a fake spread_type
    * ast_node_t flags should be removed from array, pointer, spread_type
- proc_call needs to support generic parameters:
    * ast_evaluator should compare parameters to procedure_type and raise
      errors if they don't match.
- intrinsic needs to support generic parameters, e.g. for use with range<T>(..)
- new<type<>> needs to support generic parameters for the embedded type
- BUG: comma precedence needs to be revisited now that everything is vectoring through proc_call_infix_parser.
- byte code emit for: switch, case, fallthrough
- byte code emit: for_element
- BUG: identifiers not found are returning a type inference error instead.
- REFACTOR: variable to improve how walk_to_root_and_calculate_offset is used.
- BUG: procedure_type is not allocating space on stack for locals
       also: need to emit initializers for locals
- BUG: variable lookup isn't seeing locals as stack things
- BUG: variable offset management for stack + structs is a mess
- BUG: procedure_type, procedure_call need lots of love:
    * return_element
    * procedure_call
    * argument_list
- BUG: enum type creation needs to automatically type fields and increment value.
- REVIEW: type check should enforce scalar/composite type rules.
- BUG: syntax like: support: print("hello!"); causes the compiler to end silently.
- REFACTOR: rework stack_frame (move to compiler)
            refactor procedure_type & procedure_instance to utilize stack_frame
            stack_frame instance should live off compiler::block
- REFACTOR: remove unnecessary block types from element_type_t
- NEW: anonymous block stack frame support
- NEW: uninitialized operator
- BUG: FFI stack frame requires additional data to work
- BUG: the unary_operator constant evaluator should take
       the size of the integer value into account and narrow to that size (constant-folding.bc)
- BUG: composite_type offsets incorrect within stack frame.
- NEW: implement the #run directive
       remove the automatic execution of code during compilation and replace with #run
- BUG: reintroduce dcArgStruct in ffi
- BUG: passing a string by-value on stack isn't working
        need to clean up large stack allocations after JSR
- REFACTOR: assembly_label needs to be broken into at least three subclasses
- REFACTOR: assembler::assemble_from_source should take a result-like object
            which has a pointer to the new instruction_block it creates.
- NEW: implement mechanism to identify the type of symbol for inline assembly, e.g.
        local(foo)  (local variable on the stack frame, would return offset)
        module(foo) (module variable in the image/on the heap, would return address)
        label(foo)  (a basecode label reference, would return address)
        foo         (an assembler identifier only, would return address)

        .ilocal {alias}  ; allocates an integer register
        .flocal {alias}  ; allocates a float register
- NEW: add terp trap for putc/getc for any file handle
- BUG: proc_expression needs to support overloaded procedures
- BUG: struct should conform to C ABI for padding/alignment
- BUG: finish union (ensure proper padding/alignment)
- BUG: I added a partial whitelisting approach to the terp for foreign addresses.
       For completeness, the terp needs to whitelist and moves, adds, subtracts to
       source values that are in the whitelist.
- BUG: structures aren't being padded to match what C/C++ are expecting.
        __attribute__((packed)) does allow C/C++ to align with our structures.
- BUG: unary_operator case not implemented in session::type_check
- BUG: ordering issues between types; requires deferred type checking
        (see ast_evaluator::binary_operator)
- BUG: don't recreate modules, just point references at them.  probably need to
        base this on the file name/path of the module.
- BUG: inline type declarations aren't working in ast_evaluator::type_declaration
- NEW: add support for consolidated field/parameter declarations, e.g.

    vector3 :: struct {
        x, y, z: f32;
    };

    or

    adder :: proc(a, b: s32): s32 {
        return a + b;
    };
- NEW: string literal parsing and escapes
- Code generation rewrite to move away from emit/on_emit and do everything in a byte_code_emitter for
  better state management and locality.  We need some new structures here:
    - element needs to be somehow linked to a "unit" or "section" in the assembler and this construct
      contains the related instruction_block instances;
    - this should allow for easy regeneration of a particular element and its children because we
      know what that is on the assembler side of things;
- length_of intrinsic
- NEW: length_of intrinsic for literal strings
- BUG: rework ast_evaluator::proc_call to clean up the various types of "procedure"
        clean up ast_evaluator::proc_call
- NEW: family expressions
        integers :: family(signed_integers, unsigned_integers);
        signed_integers :: family(s8, s16, s32, s64);
        unsigned_integers :: family(u8, u16, u32, u64);

        only_signed_adder :: proc<T:signed_integers>(x: T, y: T): T {
            return x + y;
        };
- FIX: unneeded temp locals in blocks
- FINISH: CFG for break, continue, and procedure calls
- NEW: for_element stack frame support
- FIX: short-hand assign+bin_op parser/ast_evaluator bug
- NEW: encode BSS address and length in terp vector table so it can zero out memory
- NEW: UFCS
- FIX: ast_evaluator::proc_call should wrap the first parameter with an address_of
        if it's not a pointer for UFCS calls
- FIX: address_of from variable_map
- FIX: byte_code_emitter::emit_block & begin_stack_frame refactoring
- OBSOLETE: finish terp::jump_to_subroutine
- FIX: type checking in family_type
- NEW: fixed length arrays; subscript operator
- NEW: length_of intrinsic for fixed arrays
- ADD: yield statement
- ADD: MADD instruction, e.g.
        MADD.W I0, 2, 2, 10

        result -> I0 = 14
- FIX: assembly_parser can't find locals or frame_offsets because they're now
        in different blocks.
- BUG: #type/type_of isn't emitting correct bytecode. missing sizes.
- FIX: type parameter constraints should now only be a
       single type instead of a tuple
- BUG: infer_type/infer_type_result_t is insufficent as-written:
    1. need to extend infer_type_result_t to support 0:n inferred type results.  this is
        particularly important for procedure_call with multiple return values.
- NEW: convert multiple/named parameters in procedure return into a tuple
- FIX: procedure multiple return types: named & unnamed
        - NEW: convert multiple/named parameters in procedure return into a tuple
- ADD (lexer): _ as the value sink literal token
- ADD (parser): value-sink _ parser
- FIX (compiler): value-sink _ should cause an error if on rhs; should not create variables
- BUG: integer_literal and float_literal should accept an override type that they return during inference.
- BUG: type interface is failing in this case:
        u64_max_u := %1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111;
                     ^ type mismatch: cannot assign s8 to u64.

ANSWERS
-------
- Q. Do we want to make type_reference's aliases match the bound identifier's
  symbol?

    See ~line 607 in ast_evaluator for note:
        - BUG: tuple.bc -- the type_reference's symbol isn't being updated to match
                the constant identifier's symbol.

  A. For now, I'm going to leave things as they are.  If it happens that this is important, it's
     easy enough to change the ast_evaluator to do this.